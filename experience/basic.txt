#include <iostream>
#include <cmath>
#include <stdexcept>
#include <memory>

// Global variable for demonstration
int globalCount = 0;

// Class representing a complex number
class Complex {
public:
    Complex(double real, double imag) : real(real), imag(imag) {
        globalCount++; // Modify global state
    }

    // Add another complex number
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }

    // Calculate the magnitude
    double magnitude() const {
        return std::sqrt(real * real + imag * imag);
    }

    // Get the real part
    double getReal() const {
        return real;
    }

    // Get the imaginary part
    double getImag() const {
        return imag;
    }

private:
    double real;
    double imag;
};

// Function to create a complex number from polar coordinates
template <typename T>
std::unique_ptr<Complex> createFromPolar(T magnitude, T angle) {
    double real = magnitude * std::cos(angle);
    double imag = magnitude * std::sin(angle);
    return std::make_unique<Complex>(real, imag);
}

int main() {
    try {
        Complex c1(1.0, 2.0);
        Complex c2(3.0, 4.0);
        Complex c3 = c1 + c2;
        std::cout << "Magnitude of c3: " << c3.magnitude() << std::endl;

        // Create from polar coordinates
        auto c4 = createFromPolar(5.0, M_PI / 4);
        std::cout << "c4 Real: " << c4->getReal() << ", Imaginary: " << c4->getImag() << std::endl;

        // Simulating a global state dependency
        std::cout << "Global count: " << globalCount << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
